/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#define STM32F446xx
#include "stm32f4xx.h"
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void)
{
	volatile uint32_t overflow_count = 0;
	volatile double frequency=0, current=0, period=0, last=0, ultima_freq=0;
	/* enable GPIOA clock */
	RCC->AHB1ENR |= 1;
	/* clear pin mode */
	GPIOA->MODER &= ~0x00000C00;
	/* set pin to alternate function */
	GPIOA->MODER |= 0x00000800;
	/* clear pin AF bits */
	GPIOA->AFR[0] &= ~0x00F00000;
	/* set pin to AF1 for TIM2 CH1 */
	GPIOA->AFR[0] |= 0x00100000;
	/* enable TIM2 clock */
	RCC->APB1ENR |= 1;
	/*divided by 1600 */
	TIM2->PSC = 1600 - 1;
	/* set counter 10000 */
	TIM2->ARR = 5*(10000-1);
	/* set output to toggle on match */
	TIM2->CCMR1 = 0x30;
	/* set match value (O led vai alterar de estado quando o contador estiver em 0) */
	TIM2->CCR1 = 0;
	/* enable CH1 compare mode */
	TIM2->CCER |= 1;
	/* clear timer counter */
	TIM2->CNT = 0;
	/* enable TIM2 */
	TIM2->CR1 = 1;


	//Habilita o pino PA7 na função alternativa
	GPIOA->MODER &= ~0x0000C000;    // Poderia usar dessa forma tmb(GPIO_MODER_MODE7_0 | GPIO_MODER_MODE5_7);
	GPIOA->MODER |= 0x00008000;     //(GPIO_MODER_MODE7_1)
	// TIM14_CH1
	GPIOA->AFR[0] &= ~ 0xF0000000;
	GPIOA->AFR[0] |=   0x90000000;

	/* Habilita o clock do TIM14 */
	RCC->APB1ENR |= RCC_APB1ENR_TIM14EN;
	/* Configura o prescaler para dividir por 800 (20kHz) */
	TIM14->PSC = 800 - 1;
	/* Configura o TIM14 para captura na borda de subida no canal 1 */
	TIM14->CCMR1 = TIM_CCMR1_CC1S_0;  // CC1S = 01 -> canal 1 como entrada
	/* Habilita a captura na borda de subida e ativa o canal */
	TIM14->CCER = TIM_CCER_CC1E;
	/* Zera o contador */
	TIM14->CNT = 0;
	/* Habilita o TIM14 */
	TIM14->CR1 = TIM_CR1_CEN;



while(1){
	while (!(TIM14->SR & 2)) {
		if(TIM14->SR & 1){   //Verifica se contou até o maximo no UIF
					overflow_count++; //add +1 nessa variavel que sera usada pra medir o tempo
					TIM14->SR &= ~1; //Limpa a flag de UIF
				}
	}/* wait until input edge is captured */
	current = TIM14->CCR1; //Salva o valor de tempo atual
	if(current>=last){
				period = (current +overflow_count*65536 - last)/20000; /* calculate the period */
				frequency = 1/ period;
				overflow_count=0;
	}
	last = current;

	//verifica se teve diferença de 2 na frequencia isso evita o led irreguar ao ajustar ele sempre
	if(frequency<50 && (abs(frequency-ultima_freq)> 2)){
				TIM2->CR1 = 0;
				TIM2->ARR = (period*10000-1);
				TIM2->CCER |= 1;
				/* clear timer counter */
				TIM2->CNT = 0;
				/* enable TIM2 */
				TIM2->CR1 = 1;
				ultima_freq = frequency;
				}


}
}
